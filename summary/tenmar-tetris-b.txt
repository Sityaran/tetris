Tetris part B
TCSS 305: Programming Practicum, Winter 2017

Name: Tenma Rollins
UWNetID: tenmar
Subversion Revision Number: 96

Assignment Overview:
This assignment was simply an extension of the previous one, requiring about as much knowledge of observer, GUI code, and so on to complete at the minimum requirements. However it was also meant to test how well we could build upon basic functionality to create more advanced extensions of existing functionality (i.e. going from a single default size game board to any particular size (within reason), going from a constantly running game to a game that can be paused or ended entirely on a whim, going from a constant difficulty to a changing one, etc.). However at the same time this assignment was assessing how we could use all of our knowledge we gained this quarter, as well as our ability to research new classes and concepts in the java core libraries to accomplish any particular goal we set out to achieve. This was mainly apparent in the option to include bonus features for extra credit in which the scope was as large was we could manage in the time limit, but at the same time we were not necessarily provided with the information on how we might even begin to start achieving some of these features from previous assignment experience.

Technical Impression:
I had already began working on some aspects of Part B in Part A, such as a pause functionality, and a scoreboard. They weren't particularly well made or entirely functional, so I began first by completing those features and cleaning their code up. The pause feature needed only to take advantage of the Observer design pattern which I added to my GUI classes, and send a PAUSE EVENT to any observers. Mainly the GUI class and the Display Class needed this, as the display needed to know when to draw a different screen overlay, and the GUI class needed to know when to not allow the user to use the movement keys (as well as pause the timer). The scoreboard was also fairly easy to implement once I got the observer design pattern set up correctly in my classes, simply updating the text based on NEW GAME events as well as when the board sent Integer[] to the update() method, which was for any line clear event. 

At this point implementing new features was fairly straightforward using observers, but I needed a way to make these events consistent across my classes, as well as reducing the need to keep looking at what string I was using for each event. I then realized that I could do this with enums! Although there was an example of enums in the model package, my main example and source of realization was how we used enums in easystreet. The ability to check against fixed, global constants consistently across classes was exactly what I needed. Thus, I simply created a class filled with enums that were all uniquely named for the events I either already had being sent between observers and observables, or that I wanted to create in the future (such and sound off and on events, and also changes in the board size). The only thing was that it was fairly tedious to go back and change each of the update() methods to now check the passed in object against enums, but that was trivial at best.

The next big hurdle was creating different board sizes. The first one required realizing the board class had a constructor that allowed for non-default (10x20) sizes in the board. The issue was that it was, however, a constructor. I could not simply call some newGame(w,h) method, so what I ended up doing was reassigning the myLogicBoard reference in my GUI class to a new Board(w,h) every time I changed the size, and then call newgame(). When I did this, though, nothing would display, not even errors. I realized then that when the new instance of the board was created, it did not inherit the listeners from the old instance. I then made a method to reconnect all the proper observers whenever I made a new board. Similarly, I disconnected the observers from the previous instance (basically calling deleteObservers() before I reassigned the board reference), so that the observers would Only be listening to the current instance of the board. I did this mainly because I had no idea where that other instance of the board class would go in memory and so I could forego any need to check for weird display bugs. However the old instance could very well have been cleaned up via garbage collection, so in retrospect, this decision to disconnect observers without doing thorough checking and testing may have been a useless one. Regardless, the fact that it works led me to believe I had at least made a safe choice. 

Creating new games via the GUI was the next feature I needed to take care of, so that I could change sizes manually without the need for the console or shortcuts or what not. What I did for this was create a menubar class, which I realized would need to extend Observable since it was going to interact with many of my other GUI classes. This meant I could not directly extend JMenuBar, but rather I had to create an instance field for it, set it up, and then return it to be used in the actual GUI. After that, the actually new game functionality was fairly easy to implement. All I needed was a JMenu, JMenuItem, and then a function to display a JOptionDialog that contained, for my tastes, two JSliders. One for width and one for height. The dialog would be opened, the user would move the sliders to the width and height of choice, and hit ok to create a new game. By hitting okay a grid change event would trigger, after which a new game event would trigger. The grid change event would be to create the new board size, and the new game event would simply start a new game and reset any statistics.

I then proceeded onto some of the extra credit features, such as sound and color. The color scheme was done by creating a map that mapped characters (one character for each block type) to different colors. Then, during the drawing of each tile, since the character of the tile would be available, I simply got the corresponding color from the current map to draw the current tile. I wanted multiple colors, however, and so I created a class that would create a standard color scheme, and also allow the user to query the map for drawing usage. This then made creating multiple maps simple, all I had to do was create another method. These methods for color schemes would then be called by using the Options->Colors... menu, triggering a color change event corresponding to the particular color scheme. Then the display and preview classes would change their current color scheme to the proper one via methods called on an instance of the color scheme class

The sound extra credit proved to be more difficult. I thought at first I could simply provide an .mp3 file and play it, but it turns out the Clip class only plays wav files, and looking on the web trying to figure out how to play .mp3 files proved to be too tedious for the amount of time I had left. Thus, I resorted to using the MusicPlayer class provided by the instructor. This class, however, lacked a certain functionality of using the Clip class, which was the ability to set loop types. I fixed this issue by changing the code in the MusicPlayer class so that when an audio file was finished playing, if a loop flag was set to true, it would then call change(0), which would then cause the player to play the audio file in the current index once more, indefinitely. Then it was a simple matter of having the music player toggle pause during the correct events to prevent weird behavior (such as playing while the mute button was checked due to the fact that pauseToggle() doesn't care whether or not the music is playing or if stopped music shouldn't start playing due to the music being muted). I didn't want to change further code so I stayed away from changing the stop() method to simply stop the music without closing it (thus saving the current spot to resume the music later if need be), because that may have ended up changing code in a lot of other places to reflect my own change. Regardless, with enough testing I got music to play only when a game is in session, and to mute properly. (toggling pause when focus changed, however, proved to create issues with how many times togglePause was called, thus resulting in the aforementioned odd behavior). 

As a final touch, I decided to add a side bar image to my Scoring Info menu, but also a custom icon of my own design to the application as well as the About dialog. The custom icon was done by simply taking some of the main Tetris colors (in this case red, yellow, blue, green, and purple) and creating a T with it. I originally thought maybe a T-block would be fitting, but it just seemed a bit too small, so I added the extra block to make a proper T shape. These blocks were drawn in a smaller canvas on Microsoft paint using the pencil tool, essentially 4x4 pixel blocks of different colors, separated by 1x2 or 2x1 gaps, thus creating the T-shape. I used the resize option in paint to maintain the aspect ratio and resize the image to 100x100, and everything scaled just fine, and saved it as a .png. After that, I edited the image in a separate editor (Paint dot net) to add transparency to the non-colored sections of the icon, at which point I was finished.

Changes to the starter code:
1. MusicPlayer.java
  - Added
    - Added myShouldLoopFlag as an indicator of whether or not to loop the current playing song.
    - Added setShouldLoop() to set the newly added flag to true or false outside of the class.
  - Changed
    - Changed package to utility to keep consistent with my setup.
    - Changed getSong() to check the myShouldLoopFlag when a song has ended to determine whether or not to play it again.
These additions and changes were made to reflect the need for the music to loop. Although looping could've been accomplished with a coded-from-scratch method of playing sound, I did not have enough time to figure out how to play .mp3 files, so I simply modified the music player code given to me.

Extra Credit:
1. Background Music: 
    Background music was added under the Options->Sounds... menu to allow picking between 2 songs (Tetris Classic and Tetris Remix), while also allowing the user to mute the sound if necessary.
2. Color Schemes:
    Color schemes were added under the Options->Colors... menu to allow picking between 2 main themes as well as choosing to invert colors or not. 
3. Visual Enhancements:
    Subtle, but I added an Icon of my own design to the window, as well as a sidebar image in the Help->Scoring Info menu so as to make some of the GUI not so plain, but still maintaining a clean look to the overall application. I was deliberately going for a clean, polished look that was pleasing to my tastes, while at the same time trying to add at least Some amount of uniqueness to my version of Tetris.

Unresolved problems in my submission:
Padding issues on the main display panel on resize were still not resolved, but the resizing works well enough that I left it as it is.

For some reason the checkstyle plugin was also analyzing my images and sound files, which caused several warnings to be shown that I could not fix.

Questions:
none


