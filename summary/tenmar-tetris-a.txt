Tetris part A 
TCSS 305: Programming Practicum, Winter 2017

Name: Tenma Rollins
UWNetID: tenmar
Subversion Revision Number: 89

Assignment Overview:
This assignment was bringing us back from a build-from-scratch mindset the previous assignment focused on, while also intensely focusing on efficient GUI/frontend development. Similarly, it stressed maintaining that idea of loose coupling throughout the back and front end code, making sure that the two parts of the code never explicitly required each other as dependencies. Rather, this assignment focused on the idea of communicating between classes using Observer design patterns in order to attach multiple unique components into a program to display a game of Tetris in a functional and possibly visually appealing manner. This first part, though, was mainly concerned with the functional part, and thus required the main components of the game (display of the game board and piece preview, along with properly mapped keyboard controls), be working as intended via the specifications.

Technical Impression:
I began coding this project with the ideas from both part A and part B in mind, however I soon realized that I should've focused more on the functionality and specifications for part A first, as a lot of time was wasted implementing yet unneeded features--although basic--that could've been spent working on a more robust and efficient solution to component layout and display resizing, as well as optimizing the setup of the key controls. Knowing this, in this summary I will talk about Part A specific additions, and leave Part B specific functionality for the future summary.

Regardless, I started first with the main Tetris display and nothing else. As soon as I had figured out how to get the game board info from the contents passed to the update() method (from the Board class), I was already stumped at how to parse this string representation of the board. I initially began by finding each instance of '\n' to determine the index of each line break. However by just parsing each "line" of the string, I was getting the borders of the game board as well as the invisible upper area. This was far too much unnecessary information in each line. So next I began finding the index of both '|' and '|\n' for each row and then moving the contents between these indices into their own strings in an ArrayList. This served fine for getting each individual line between the side walls, but still contained the upper area, and two dividing lines of the board. I realized from this point that I could simply find the first occurrence of "-\n" which would signify the end of the upper area, and then add lines until right before the last occurrence of "|-" which would signify the end of the main displayable area. Taking the contents of each of these rows (between the borders), proved to be sufficient to fill the ArrayList with the proper line contents. 

After I had successfully parsed the string I began work on displaying it. I had the aspect ratio (1:2) in mind for the 10x20 game grid to display, as well as an inkling of how to display properly scaled squares in this display area. So I immediately created nested for loops. The outside one being the y-values (since each string in the ArrayList was a row), and the inside one being the x-values (since each character in the string for the given row referred to the piece in that row at that column position). This proved to be simple enough, iterating through the list, and then for each line, iterating through its Character array. Now was the issue with the scale factor, which turned out not to be an issue at all. Since the aspect ratio corresponded exactly with the 10x20 grid size, taking either the WIDTH / X_GRID_SIZE or the HEIGHT / Y_GRID_SIZE would yield the same length for a single box in the display. Thus, using that side length, and finding when an index in the line was filled with a tile, I simply drew a box at the corresponding x and y coordinate (scaled by the side length) and then let its width and height equal the side length. To leave some work for the future assignment, Part B, I colored the boxes in plain, uniform colors in order to focus mainly on functionality. 

After the display had been accomplished, it was a simple matter of hooking up a KeyListener and a TimerListener to the JFrame and Timer respectively. This was sufficient in allowing down() to be called on the Board class every second, as well as allow keyboard controls to call down() and other methods on the Board class in order to manipulate the display of the game board. Since the display simply parsed the string passed to it by the Board class, there was no further work to be done in the display. 

Then came the piece preview. From the previous parsing experiments done on the information passed to update() by the Board class, I found that before the game board is initially passed, a string containing a single piece oriented in its base state is passed. Knowing this information, I determined that a new piece was passed into update() before each new piece begins falling in the board. I parsed this piece string much the same as the board, but since there were no borders to worry about, I could simply use the index of '\n' to determine the end-line for each row of tiles, and add it to a list. Using this parsing, I discovered that the pieces were given in a 4x4 grid of tiles, and that they were all oriented within the middle two rows. Further experimentation (looking at each piece displayed as a string), led me to discover that all 3-wide pieces were offset by 0.5 in x from the direct center of the 4x4 grid, the 2-wide (O piece) is already centered, and the 4-wide piece was offset by 0.5 in y from the direct center. Using this information, I could draw the pieces based on their width to determine the proper offset for drawing them. Padding was then added to make sure the centered piece did not ever fill the preview from edge to edge, and displayed in a visually appealing manner.

Moving on, the informational panel was done with a simple JPanel set to a vertical Box Layout, and then JLabels added with the proper text in sequence. So it was a trivial addition to the overall GUI at best. 

After that was done, I began to tackle the extra credit of resizing the window and display gracefully. This was done mainly by knowing that repaint() was called whenever the parent swing component of the JPanel was resized, thus I added a resize() method to the paintComponent() method. In this resize method, I knew that the main thing I needed to do was maintain the aspect ratio. Thus, I found the current ratio (10.0 / 20.0) or (1:2), and then found the current ratio of the JPanel (WIDTH : HEIGHT), and then checked if the required ratio was less than the current ratio. If it was, this meant that the JPanel was too wide, thus I resize the width via HEIGHT * 10 / 20 so that Required Ratio = Current Ratio. For the other case, the height was too large, so it was resized. Through this, the aspect ratio was maintained on resize. The only other issue was the scale factor, which then had to be recalculated based on the new size. Since the aspect ratio was maintained, again either WIDTH / X_GRID_SIZE or HEIGHT / Y_GRID_SIZE could be used to maintain a proper scale factor that would draw perfect squares properly. 

Changes to the starter code:
none

Extra Credit:
Graceful resize: I was able to get the aspect ratio of the JPanel to remain constant throughout resizing, as well as enforced a minimum size that the entire program could be.

Unresolved problems in my submission:
I was not able to solve the issue regarding the odd padding between the JPanel and other components within the Box. (This happened on other layouts as well). There seems to be a positioning calculation issue when setting size and preferred size of the JPanel. I've been working on a partial solution using GridBag layout, but I do not have any more time for this part of the project to implement it.

Questions:
none

